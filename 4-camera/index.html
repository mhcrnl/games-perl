<P>Following
posts <a href="http://daniel.ruoso.com/categoria/perl/games-perl-1">1</A>,
<a href="http://daniel.ruoso.com/categoria/perl/games-perl-2">2</A> and
<a href="http://daniel.ruoso.com/categoria/perl/games-perl-2">3</A>
on the subject of writing games in Perl, now we are going to add
a camera.</P>

<P>Up to this point, we've been coupling the positional information in
our simulated universe with the screen position. This is very easy to
do, but very limiting as well, how can we represent off-screen
elements that way?</P>

<P>Our next step is to implement a camera. The idea is quite simple,
instead of asking for each model object to render itself, We're going
to:</P>

<OL>
<LI>Initialize a view object for each of the model objects.</LI>
<LI>Detect which model objects are in the current view sight of the
camera.</LI>
<LI>Send to the view objects the positional information of the model
objects.
<LI>Ask the view objects to draw themselves.
</OL>

<P>At this point you might have noticed that I'm using the terms
"model" and "view" as a direct reference to the Model-View-Controller
architecture, and that's precisely my intention. The basic idea is:
The model is only responsible for managing the simulation of our
universe, while the view is only responsible for turning that
simulation visible to the user. The Controller here is the code that
implements the main loop, receiving the user events, and coordinating
the FPS management.</P>

<P>I could list several reasons on why having the model and the view
as separated objects is a good idea, but I'd like two point just two
of them, since these are going to be future topics in this
tutorial:</P>

<OL>
<LI>You can apply "themes" to the visualization, like "hi-res" and
"low-res" simply by changing the initialization of the view, adding
support for zoom and rotation is also very simple.
<LI>You can have the calculations on the simulation side in a
different thread then the rendering of the objects, enabling our game
to take advantage on multi-core systems.</LI>
</OL>

<P>Enough on the introduction, let's start coding.</P>

<P>The first thing I'm going to do is reorganize our current module
layout. Up to this point our code had:

<UL>
<LI>ball.pl
<LI>lib/Ball.pm</LI>
<LI>lib/Wall.pm</LI>
<LI>lib/Util.pm</LI>
</UL>

<P>But now we're going to need a different layout, here is our target
organization:</P>

<DL>
<DT>ball.pl</DT>
<DD>This is still going to be our main script, but we're going to have
less code in it.</DD>
<DT>lib/BouncingBall/Model/Ball.pm</DT>
<DD>Yes, I named our game BouncingBall, and the first model class is
the ball itself, it will look much like the current code, but the
"get_rect" and the "draw" methods won't be there.
<DT>lib/BouncingBall/Model/Wall.pm</DT>
<DD>This looks like our current Wall code, but as with the ball,
"get_rect" and "draw" won't be there.</DD>
<DT>lib/BouncingBall/Controller/InGame.pm</DT>
<DD>At this point we're only going to have one controller, but the
general idea is that we're going to have one controller for each of
the main states of the game, like "MainMenu", "Paused", "InGame",
"GameOver" etc. The InGame controller will implement the code that is
currently inside the main loop of ball.pl</DD>
<DT>lib/BouncingBall/View/FilledRect.pm</DT>
<DD>Currently, our ball and our wall are just filled rectangles, so
we're going to preserve that for now. This is interesting to make the
view vs model point even more clear. The view doesn't need to be aware
of what it is representing, as long as it knows how to do it. In our
case, it doesn't need to know if it is representing a Ball or a Wall,
it simply needs to know where it is and what color to paint. This is
also going to be used for the background.</DD>
<DT>lib/BouncingBall/View/MainSurface.pm</DT>
<DD>This class represents the main application surface, it is special
because it needs to configure the video mode, but it is also a
dependency for the FilledRect view, since it needs to blit itself
somewhere.</DD>
<DT>lib/BouncingBall/View/Camera.pm</DT>
<DD>This is the view class that will implement the mapping of
coordinates from the simulated universe to the MainSurface, the
FilledRect also depends on this class.</DD>
</DL>


