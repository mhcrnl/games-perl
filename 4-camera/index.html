<P>Following
posts <a href="http://daniel.ruoso.com/categoria/perl/games-perl-1">1</A>,
<a href="http://daniel.ruoso.com/categoria/perl/games-perl-2">2</A> and
<a href="http://daniel.ruoso.com/categoria/perl/games-perl-2">3</A>
on the subject of writing games in Perl, now we are going to add
a camera.</P>

<P>Up to this point, we've been coupling the positional information in
our simulated universe with the screen position. This is very easy to
do, but very limiting as well, how can we represent off-screen
elements that way?</P>

<P>Our next step is to implement a camera. The idea is quite simple,
instead of asking for each model object to render itself, We're going
to:</P>

<OL>
<LI>Initialize a view object for each of the model objects.</LI>
<LI>Detect which model objects are in the current view sight of the
camera.</LI>
<LI>Send to the view objects the positional information of the model
objects.
<LI>Ask the view objects to draw themselves.
</OL>

<P>At this point you might have noticed that I'm using the terms
"model" and "view" as a direct reference to the Model-View-Controller
architecture, and that's precisely my intention. The basic idea is:
The model is only responsible for managing the simulation of our
universe, while the view is only responsible for turning that
simulation visible to the user. The Controller here is the code that
implements the main loop, receiving the user events, and coordinating
the FPS management.</P>

<P>I could list several reasons on why having the model and the view
as separated objects is a good idea, but I'd like two point just two
of them, since these are going to be future topics in this
tutorial:</P>

<OL>
<LI>You can apply "themes" to the visualization, like "hi-res" and
"low-res" simply by changing the initialization of the view, adding
support for zoom and rotation is also very simple.
<LI>You can have the calculations on the simulation side in a
different thread then the rendering of the objects, enabling our game
to take advantage on multi-core systems.</LI>
</OL>

<h3>Code Layout</h3>

<P>The first thing I'm going to do is reorganize our current module
layout. Up to this point our code had:

<UL>
<LI>ball.pl
<LI>lib/Ball.pm</LI>
<LI>lib/Wall.pm</LI>
<LI>lib/Util.pm</LI>
</UL>

<P>But now we're going to need a different layout, here is our target
organization:</P>

<DL>
<DT>ball.pl</DT>
<DD>This is still going to be our main script, but we're going to have
less code in it.</DD>
<DT>lib/BouncingBall.pm</DT>
<DD>Main application module, most of the code currently in ball.pl
goes here.</DD>
<DT>lib/BouncingBall/Model/Ball.pm</DT>
<DD>Yes, I named our game BouncingBall, and the first model class is
the ball itself, it will look much like the current code, but the
"get_rect" and the "draw" methods won't be there.
<DT>lib/BouncingBall/Model/Wall.pm</DT>
<DD>This looks like our current Wall code, but as with the ball,
"get_rect" and "draw" won't be there.</DD>
<DT>lib/BouncingBall/Controller/InGame.pm</DT>
<DD>At this point we're only going to have one controller, but the
general idea is that we're going to have one controller for each of
the main states of the game, like "MainMenu", "Paused", "InGame",
"GameOver" etc. The InGame controller will implement the code that is
currently inside the main loop of ball.pl</DD>
<DT>lib/BouncingBall/View/FilledRect.pm</DT>
<DD>Currently, our ball and our wall are just filled rectangles, so
we're going to preserve that for now. This is interesting to make the
view vs model point even more clear. The view doesn't need to be aware
of what it is representing, as long as it knows how to do it. In our
case, it doesn't need to know if it is representing a Ball or a Wall,
it simply needs to know where it is and what color to paint. This is
also going to be used for the background.</DD>
<DT>lib/BouncingBall/View/MainSurface.pm</DT>
<DD>This class represents the main application surface, it is special
because it needs to configure the video mode, but it is also a
dependency for the FilledRect view, since it needs to blit itself
somewhere.</DD>
<DT>lib/BouncingBall/View/Camera.pm</DT>
<DD>This is the view class that will implement the mapping of
coordinates from the simulated universe to the MainSurface, the
FilledRect also depends on this class.</DD>
</DL>

<h3>General flow</h3>

<OL>
<LI>ball.pl initializes the BouncingBall module.
<LI>BouncingBall initializes the MainSurface view, as this view is
special and is preserved during the entire application lifetime,
independent of the controller in charge right now.</LI>
<LI>As we don't implement game menu or any other fancy stuff, we go
directly to the game. That means we'll initialize the InGame
Controller.</LI>
<LI>The connection between the views and the models is defined by the
controller, so it needs to initialize the models, the views and
connect them together.</LI>
<LI>After the initialization, we're ready for the game loop, which is,
at this point, entirely handled by the InGame controller.</LI>
</OL>

<h3>The case for Observers</h3>

<P>A naive implementation of the connection between the models and the
views would be, at each step, to fetch the relevant information from
the model and set it into the view. Or possibly have the view itself
fetch the data from the model. But there's one important point to
consider, if the model and the view ends in a different thread,
accessing each other's data would become significantly complicated.</P>

<P>That being said, a different mechanism for view-model integration
is necessary. If we go to the way GUI toolkits work, we'll notice a
pattern called "The Observer Pattern", basically, one object registers
itself as "observing" the other. When that specific type of event
happens, a pre-defined method is called in the observing object.</P>

<P>So what we're going to do is to preserve a local cache of the
information that view needs from the model, use it directly and get it
updated using the observer pattern. That way we have the model and the
view decoupled in terms of threading.</P>

<h3>To the code</h3>

<P>The first thing we need to do is porting our Ball and Wall into
proper model objects, at first, simply removing the "get_rect" and
"draw" methods. I'm not going to put all its code again here, but
renaming the modules and removing that methods is the only thing I'm
doing right now.</P>

<P>Now we need to step-by-step get to the final code layout presented
earlier, let's start by the view classes, and in that case, let's get
the most important view class, the MainSurface.</P>

<PRE>
package BouncingBall::View::MainSurface;
use Moose;
use SDL ':all';
use SDL::Video ':all';

has 'surface' => (is => 'rw');
has 'width' => (is => 'ro', default => 800);
has 'height' => (is => 'ro', default => 600);
has 'depth' => (is => 'ro', default => 32);

sub BUILD {
    my ($self) = @_;

    die 'Cannot init ' . SDL::get_error()
      if ( SDL::init( SDL_INIT_VIDEO ) == -1 );

    $self->surface
      ( SDL::Video::set_video_mode
        ( $self->width, $self->height, $self->depth,
          SDL_HWSURFACE | SDL_DOUBLEBUF | SDL_HWACCEL ))
        or die 'Error initializing video.';
}
</PRE>

<P>Here we use Moose object initialization to initialize the SDL Video
subsystem and get a new surface for the required videomode. This is a
bit different then what we were doing in the original ball.pl, but not
much. The most important difference is that we're now using double
hardware buffering, which is more efficient then doing individual
updates.</P>

<P>Now we need the Camera view, which is going to implement the logic
on translating the coordinates from each object to the current
visualization. This is a very important decoupling in our logic,
because it is here that we relativize the points from the simulated
universe to the screen. And this is going to be done by setting a
camera position which is going to serve as pivot in the coordinate
translation.</P>

<P>This is going to be implemented through three methods in our
camera, one that converts a distance in meters to pixels, other that
converts a coordinate to the screen and finally one that checks if a
coordinate is visible at that moment.</P>

<PRE>
package BouncingBall::View::Camera;
use Moose;

has pointing_x => ( is => 'rw',
                    isa => 'Int',
                    default => 0 );
has pointing_y => ( is => 'rw',
                    isa => 'Int',
                    default => 0 );
has dpi        => ( is => 'rw',
                    isa => 'Int',
                    default => 0.96 );
has pixels_w   => ( is => 'ro',
                    isa => 'Int',
                    required => 1 );
has pixels_h   => ( is => 'ro',
                    isa => 'Int',
                    required => 1 );

sub m2px {
    my ($self, $input) = @_;
    return int((($input) * ($self->dpi / 0.0254)) + 0.5);
}

sub px2m {
    my ($self, $input) = @_;
    return ($input) / ($self->dpi / .0254);
}

sub width {
    my ($self) = @_;
    return $self->px2m($self->pixels_w);
}

sub height {
    my ($self) = @_;
    return $self->px2m($self->pixels_h);
}

sub translate {
    my ($self, $x, $y) = @_;
    # here is where we translate our system from the simulated
    # universe, where 0m is at the bottom and the screen where 0px is
    # at the top of the screen.  We also translate the point relative
    # to where the camera is pointing right now.
    my $uplf_x = $self->pointing_x - ($self->width / 2);
    my $uplf_y = $self->pointing_y - ($self->height / 2);
    my $rel_x = $x - $uplf_x;
    my $rel_y = $y - $uplf_y;
    my $pix_x = $self->m2px($rel_x);
    my $pix_y = $self->m2px($rel_y);
    my $inv_y = $self->pixels_h - $pix_y;
    return ($pix_x, $inv_y);
}

sub is_visible {
    my ($self, $x, $y) = @_;
    my ($tx, $ty) = $self->translate($x, $y);
    if ($tx > 0 && $ty > 0 &&
        $tx < $self->pixels_w &&
        $ty < $self->pixels_h) {
        return 1;
    } else {
        return 0;
    }
}
</PRE>

<P>The Camera requires the information from the MainSurface on the
ammount of pixels it has to be able to do the translations.</P>


