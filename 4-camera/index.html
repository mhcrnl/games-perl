<P>Following
posts <a href="http://daniel.ruoso.com/categoria/perl/games-perl-1">1</A>,
<a href="http://daniel.ruoso.com/categoria/perl/games-perl-2">2</A> and
<a href="http://daniel.ruoso.com/categoria/perl/games-perl-2">3</A>
on the subject of writing games in Perl, now we are going to add
a camera.</P>

<P>Up to this point, we've been coupling the positional information in
our simulated universe with the screen position. This is very easy to
do, but very limiting as well, how can we represent off-screen
elements that way?</P>

<P>Our next step is to implement a camera. The idea is quite simple,
instead of asking for each model object to render itself, We're going
to:</P>

<OL>
<LI>Initialize a view object for each of the model objects.</LI>
<LI>Detect which model objects are in the current view sight of the
camera.</LI>
<LI>Send to the view objects the positional information of the model
objects.
<LI>Ask the view objects to draw themselves.
</OL>

<P>At this point you might have noticed that I'm using the terms
"model" and "view" as a direct reference to the Model-View-Controller
architecture, and that's precisely my intention. The basic idea is:
The model is only responsible for managing the simulation of our
universe, while the view is only responsible for turning that
simulation visible to the user. The Controller here is the code that
implements the main loop, receiving the user events, and coordinating
the FPS management.</P>

<P>I could list several reasons on why having the model and the view
as separated objects is a good idea, but I'd like two point just two
of them, since these are going to be future topics in this
tutorial:</P>

<OL>
<LI>You can apply "themes" to the visualization, like "hi-res" and
"low-res" simply by changing the initialization of the view, adding
support for zoom and rotation is also very simple.
<LI>You can have the calculations on the simulation side in a
different thread then the rendering of the objects, enabling our game
to take advantage on multi-core systems.</LI>
</OL>

<h3>Code Layout</h3>

<P>The first thing I'm going to do is reorganize our current module
layout. Up to this point our code had:

<UL>
<LI>ball.pl
<LI>lib/Ball.pm</LI>
<LI>lib/Wall.pm</LI>
<LI>lib/Util.pm</LI>
</UL>

<P>But now we're going to need a different layout, here is our target
organization:</P>

<DL>
<DT>ball.pl</DT>
<DD>This is still going to be our main script, but we're going to have
less code in it.</DD>
<DT>lib/BouncingBall.pm</DT>
<DD>Main application module, most of the code currently in ball.pl
goes here.</DD>
<DT>lib/BouncingBall/Model/Ball.pm</DT>
<DD>Yes, I named our game BouncingBall, and the first model class is
the ball itself, it will look much like the current code, but the
"get_rect" and the "draw" methods won't be there.
<DT>lib/BouncingBall/Model/Wall.pm</DT>
<DD>This looks like our current Wall code, but as with the ball,
"get_rect" and "draw" won't be there.</DD>
<DT>lib/BouncingBall/Controller/InGame.pm</DT>
<DD>At this point we're only going to have one controller, but the
general idea is that we're going to have one controller for each of
the main states of the game, like "MainMenu", "Paused", "InGame",
"GameOver" etc. The InGame controller will implement the code that is
currently inside the main loop of ball.pl</DD>
<DT>lib/BouncingBall/View/Plane.pm</DT>
<DD>This implements the background.</DD>
<DT>lib/BouncingBall/View/FilledRect.pm</DT>
<DD>Currently, our ball and our wall are just filled rectangles, so
we're going to preserve that for now. This is interesting to make the
view vs model point even more clear. The view doesn't need to be aware
of what it is representing, as long as it knows how to do it. In our
case, it doesn't need to know if it is representing a Ball or a Wall,
it simply needs to know where it is and what color to paint.</DD>
<DT>lib/BouncingBall/View/MainSurface.pm</DT>
<DD>This class represents the main application surface, it is special
because it needs to configure the video mode, but it is also a
dependency for the FilledRect view, since it needs to blit itself
somewhere.</DD>
<DT>lib/BouncingBall/View/Camera.pm</DT>
<DD>This is the view class that will implement the mapping of
coordinates from the simulated universe to the MainSurface, the
FilledRect also depends on this class.</DD>
<DT>lib/BouncingBall/Event/RectMoved.pm</DT>
<DD>Typed event that describes the movement of some object represented
by its enclosing rect.</DD>
<DT>lib/BouncingBall/Event/Rect.pm</DT>
<DD>Object describing a simple rect (using floating-point instead of
integer), to be used by RectMoved.</DD>
<DT>lib/BouncingBall/Event/MovingRectObservable.pm</DT>
<DD>Moose role that implements the logic for being a class that can be
observed.</DD>
<DT>lib/BouncingBall/Event/MovingRectObserver.pm</DT>
<DD>Moose role that defines the type of the observer class.</DD>
</DL>

<h3>General flow</h3>

<OL>
<LI>ball.pl initializes the BouncingBall module.
<LI>BouncingBall initializes the MainSurface view, as this view is
special and is preserved during the entire application lifetime,
independent of the controller in charge right now.</LI>
<LI>As we don't implement game menu or any other fancy stuff, we go
directly to the game. That means we'll initialize the InGame
Controller.</LI>
<LI>The connection between the views and the models is defined by the
controller, so it needs to initialize the models, the views and
connect them together.</LI>
<LI>After the initialization, we're ready for the game loop, which is,
at this point, entirely handled by the InGame controller.</LI>
</OL>

<h3>The case for Observers</h3>

<P>A naive implementation of the connection between the models and the
views would be, at each step, to fetch the relevant information from
the model and set it into the view. Or possibly have the view itself
fetch the data from the model. But there's one important point to
consider, if the model and the view ends in a different thread,
accessing each other's data would become significantly complicated.</P>

<P>That being said, a different mechanism for view-model integration
is necessary. If we go to the way GUI toolkits work, we'll notice a
pattern called "The Observer Pattern", basically, one object registers
itself as "observing" the other. When that specific type of event
happens, a pre-defined method is called in the observing object.</P>

<P>So what we're going to do is to preserve a local cache of the
information that view needs from the model, use it directly and get it
updated using the observer pattern. That way we have the model and the
view decoupled in terms of threading.</P>

<h3>To the code</h3>

<P>The first thing we need to do is porting our Ball and Wall into
proper model objects, at first, simply removing the "get_rect" and
"draw" methods. I'm not going to put all its code again here, but
renaming the modules and removing that methods is the only thing I'm
doing right now.</P>

<P>Now we need to step-by-step get to the final code layout presented
earlier, let's start by the view classes, and in that case, let's get
the most important view class, the MainSurface.</P>

<PRE>
package BouncingBall::View::MainSurface;
use Moose;
use SDL ':all';
use SDL::Video ':all';

has 'surface' => (is => 'rw');
has 'width' => (is => 'ro', default => 800);
has 'height' => (is => 'ro', default => 600);
has 'depth' => (is => 'ro', default => 32);

sub BUILD {
    my ($self) = @_;

    die 'Cannot init ' . SDL::get_error()
      if ( SDL::init( SDL_INIT_VIDEO ) == -1 );

    $self->surface
      ( SDL::Video::set_video_mode
        ( $self->width, $self->height, $self->depth,
          SDL_HWSURFACE | SDL_DOUBLEBUF | SDL_HWACCEL ))
        or die 'Error initializing video.';
}
</PRE>

<P>Here we use Moose object initialization to initialize the SDL Video
subsystem and get a new surface for the required videomode. This is a
bit different then what we were doing in the original ball.pl, but not
much. The most important difference is that we're now using double
hardware buffering, which is more efficient then doing individual
updates.</P>

<P>Now we need the Plane view, which implements the background.</P>

<PRE>
package BouncingBall::View::Plane;
use Moose;
use SDL::Video ':all';
use SDL::Surface;

has color     => ( is => 'rw',
                   default => 0 );
has surface   => ( is => 'rw' );
has color_obj => ( is => 'rw' );
has main      => ( is => 'ro',
                   required => 1 );

sub BUILD {
    my ($self) = @_;
    $self->_init_surface;
    $self->_init_color_object;
    $self->_init_rect;
    $self->_fill_rect;
}

sub _init_surface {
    my ($self) = @_;
    $self->surface
      ( SDL::Surface->new
        ( SDL_SWSURFACE,
          $self->main->width,
          $self->main->height,
          $self->main->depth,
          0, 0, 0, 255 ) );
}

sub _init_color_object {
    my ($self) = @_;
    $self->color_obj
      ( SDL::Video::map_RGB
        ( $self->main->surface->format,
          0xFF0000 & $self->color,
          0x00FF00 & $self->color,
          0x0000FF & $self->color ));
}

sub _init_rect {
    my ($self) = @_;
    $self->rect_obj
      ( SDL::Rect->new
        ( 0, 0,
          $self->main->width,
          $self->main->height ) );
}

sub _fill_rect {
    my ($self) = @_;
    SDL::Video::fill_rect
        ( $self->surface,
          $self->rect_obj,
          $self->color_obj );
}

after 'color' => sub {
    my ($self, $color) = @_;
    if ($color) {
        $self->_init_color_object;
        $self->_fill_rect;
    }
    return $color;
};

sub draw {
    my ($self) = @_;
    SDL::Video::blit_surface
        ( $self->surface, $self->rect_obj,
          $self->main->surface, $self->rect_obj );
}
</PRE>

<P>Now we need the Camera view, which is going to implement the logic
on translating the coordinates from each object to the current
visualization. This is a very important decoupling in our logic,
because it is here that we relativize the points from the simulated
universe to the screen. And this is going to be done by setting a
camera position which is going to serve as pivot in the coordinate
translation.</P>

<P>This is going to be implemented through three methods in our
camera, one that converts a distance in meters to pixels, other that
converts a coordinate to the screen and finally one that checks if a
coordinate is visible at that moment.</P>

<PRE>
package BouncingBall::View::Camera;
use Moose;

has pointing_x => ( is => 'rw',
                    default => 0 );
has pointing_y => ( is => 'rw',
                    default => 0 );
has dpi        => ( is => 'rw',
                    default => 0.96 );
has pixels_w   => ( is => 'ro',
                    required => 1 );
has pixels_h   => ( is => 'ro',
                    required => 1 );

sub m2px {
    my ($self, $input) = @_;
    return int((($input) * ($self->dpi / 0.0254)) + 0.5);
}

sub px2m {
    my ($self, $input) = @_;
    return ($input) / ($self->dpi / .0254);
}

sub width {
    my ($self) = @_;
    return $self->px2m($self->pixels_w);
}

sub height {
    my ($self) = @_;
    return $self->px2m($self->pixels_h);
}

sub translate {
    my ($self, $x, $y) = @_;
    # here is where we translate our system from the simulated
    # universe, where 0m is at the bottom and the screen where 0px is
    # at the top of the screen.  We also translate the point relative
    # to where the camera is pointing right now.
    my $uplf_x = $self->pointing_x - ($self->width / 2);
    my $uplf_y = $self->pointing_y - ($self->height / 2);
    my $rel_x = $x - $uplf_x;
    my $rel_y = $y - $uplf_y;
    my $pix_x = $self->m2px($rel_x);
    my $pix_y = $self->m2px($rel_y);
    my $inv_y = $self->pixels_h - $pix_y;
    return ($pix_x, $inv_y);
}

sub is_visible {
    my ($self, $x, $y) = @_;
    my ($tx, $ty) = $self->translate($x, $y);
    if ($tx > 0 && $ty > 0 &&
        $tx < $self->pixels_w &&
        $ty < $self->pixels_h) {
        return 1;
    } else {
        return 0;
    }
}
</PRE>

<P>The Camera requires the information from the MainSurface on the
ammount of pixels it has to be able to do the translations.</P>

<P>Now we need to implement the FilledRect view class.</P>

<PRE>
package BouncingBall::View::FilledRect;
use Moose;
use SDL::Video ':all';
use SDL::Surface;

has x         => ( is => 'rw',
                   default => 0 );
has y         => ( is => 'rw',
                   default => 0 );
has w         => ( is => 'rw',
                   default => 0 );
has h         => ( is => 'rw',
                   default => 0 );
has color     => ( is => 'rw',
                   default => 0 );
has rect_obj  => ( is => 'rw' );
has surface   => ( is => 'rw' );
has color_obj => ( is => 'rw' );
has camera    => ( is => 'rw',
                   required => 1 );
has main      => ( is => 'rw',
                   required => 1 );

sub BUILD {
    my ($self) = @_;
    $self->_init_surface;
    $self->_init_color_object;
    $self->_init_rect;
    $self->_fill_rect;
}

sub _init_surface {
    my ($self) = @_;
    $self->surface
      ( SDL::Surface->new
        ( SDL_SWSURFACE,
          $self->camera->m2px($self->w),
          $self->camera->m2px($self->h),
          $self->main->depth,
          0, 0, 0, 255 ) );
}

sub _init_color_object {
    my ($self) = @_;
    $self->color_obj
      ( SDL::Video::map_RGB
        ( $self->main->surface->format,
          0xFF0000 & $self->color,
          0x00FF00 & $self->color,
          0x0000FF & $self->color ));
}

sub _init_rect {
    my ($self) = @_;
    $self->rect_obj
      ( SDL::Rect->new
        ( 0, 0,
          $self->camera->m2px($self->w),
          $self->camera->m2px($self->h) ) );
}

sub _fill_rect {
    my ($self) = @_;
    SDL::Video::fill_rect
        ( $self->surface,
          $self->rect_obj,
          $self->color_obj );
}

after 'color' => sub {
    my ($self, $color) = @_;
    if ($color) {
        $self->_init_color_object;
        $self->_fill_rect;
    }
    return $color;
};

after qw(w h) => sub {
    my ($self, $newval) = @_;
    if ($newval) {
        $self->_init_surface;
        $self->_init_rect;
        $self->_fill_rect;
    }
    return $newval;
};

sub draw {
    my ($self) = @_;
    SDL::Video::blit_surface
        ( $self->surface, $self->rect_obj,
          $self->main->surface,
          SDL::Rect->new
          ( $self->camera->translate( $self->x, $self->y ),
            $self->rect_obj->w, $self->rect_obj->h ) );
}
</PRE>

<P>Ok, now that we have the Model and the View classes, we can
implement the observer pattern, so the view can be updated as the
model changes.</P>

<P>One important aspect on how the MVC model works is that the
controller should have just a limited control on the interaction
between the model and the view, otherwise you'll get a very
complicated code in the controller. Ideally you should have the same
level of abstraction in the model as you have in the view, so you have
componentization of your application.</P>

<P>That being said, we need to plan the communication pattern between
the view and the model. It is important that they should be mostly
unaware of each other, in the sense that the view doesn't need to know
that it's a ball being modelled, but just that it has a point
describing its position and a rect describing its measures - We can
even keep only the rect for our current purposes.</P>

<P>That is our RectMoved event class and the Rect class which is used
by it:</P>

<PRE>
package BouncingBall::Event::RectMoved;
use Moose;

has old_rect => ( is => 'ro',
                  isa => 'BouncingBall::Event::Rect',
                  required => 0 );
has new_rect => ( is => 'ro',
                  isa => 'BouncingBall::Event::Rect',
                  required => 1 );

</PRE>

<PRE>
package BouncingBall::Event::Rect;
use Moose;

has x => ( is => 'ro',
           isa => 'Numeric',
           required => 1 );
has y => ( is => 'ro',
           isa => 'Numeric',
           required => 1 );
has w => ( is => 'ro',
           isa => 'Numeric',
           required => 1 );
has h => ( is => 'ro',
           isa => 'Numeric',
           required => 1 );
</PRE>

<P>Now we need the role that implements the observable part, meaning
that any class that wants to fire events for moving rects just need to
compose that role and call the fire_rect_moved method.</P>

<PRE>
package BouncingBall::Event::RectMovingObservable;
use Moose::Role;
use MooseX::Types::Moose qw(ArrayRef);

use aliased 'BouncingBall::Event::RectMovingObserver';
use aliased 'BouncingBall::Event::RectMoved';

has 'rect_moving_listeners' => ( traits => ['Array'],
                                 is => 'ro',
                                 isa => ArrayRef[RectMovingObserver],
                                 default => sub { [] },
                                 handles => { add_rect_moving_listener => 'push' } );

sub remove_rect_moving_listener {
    my ($self, $object) = @_;
    my $count = $self->rect_moving_listeners->count;
    my $found;
    for my $i (0..($count-1)) {
        if ($self->rect_moving_listeners->[$i] == $object) {
            $found = $i;
            last;
        }
    }
    if ($found) {
        $self->rect_moving_listeners->splice($found, 1, ());
    }
}

sub fire_rect_moved {
    my ($self, $old_rect, $new_rect) = @_;
    my $ev = RectMoved->new({ old_rect => $old_rect,
                              new_rect => $new_rect });
    $self->rect_moving_listeners->map({ $_->rect_moved($ev) });
}
</PRE>

<P>And the RectMovingObserver role:</P>

<PRE>
package BouncingBall::Event::RectMovingObserver;
use Moose::Role;

requires 'rect_moved';
</PRE>

<P>Now we need to make our Ball model class fire that event whenever
its position or size attributes are changed. So we're goint to add the
following modifiers to the attributes. At first we're not going to
support the old_rect attribute of the event, so we're just sending the
new_rect.</P>

<PRE>
with 'BouncingBall::Event::RectMovingObservable';

after qw(cen_v cen_h) => sub {
    my ($self, $newval) = @_;
    if ($newval) {
        $self->fire_rect_moved( undef,
                                Rect->new({ x => $self->pos_h,
                                            y => $self->pos_v,
                                            w => $self->width,
                                            h => $self->height }) );
    }
}
</PRE>

<P>And finally adding the observer code in the view class.</P>

<PRE>
with 'BouncingBall::Event::RectMovingObserver';

sub rect_moved {
    my ($self, $ev) = @_;
    $self->$_($ev->$_()) for grep { $self->$_() != $ev->$_() } qw(x y w h);
}
</PRE>

<H3>Everything's set! To the controller!</H3>

<P>Now we finally can have the controller code written. It should:</P>

<OL>
<LI>Initialize the models</LI>
<LI>Initialize the views</LI>
<LI>Connect them together</LI>
<LI>Orchestrate the time_lapse and the general rendering</LI>
</OL>
